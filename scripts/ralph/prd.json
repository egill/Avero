{
  "branchName": "ralph/perf-fixes",
  "userStories": [
    {
      "id": "US-001",
      "title": "Decouple gate commands from tracker loop",
      "category": "performance",
      "acceptanceCriteria": [
        "Gate command sends via spawned GateCmdWorker task",
        "Tracker enqueues command and returns immediately (never awaits network)",
        "Worker measures queue delay + send latency",
        "Metrics updated: queue_delay_us, send_latency_us",
        "Gate state payloads include timing info",
        "All existing tests pass"
      ],
      "instructions": "Create src/services/gate_worker.rs with GateCmdWorker that owns GateController. Add gate_cmd_tx: mpsc::Sender<GateCmd> to Tracker. send_gate_open_command becomes 'enqueue + record timestamp' and returns immediately. Worker does actual send_open_command, measures latency, updates metrics. Adjust src/main.rs to spawn worker.",
      "files": ["src/services/tracker/handlers.rs", "src/services/gate_worker.rs (new)", "src/main.rs"],
      "priority": 0,
      "passes": false,
      "notes": "CRITICAL: Primary cause of 'gate open too late'. Creates new gate_worker.rs module."
    },
    {
      "id": "US-002",
      "title": "Make MQTT/ACC event sending non-blocking with drop metrics",
      "category": "performance",
      "acceptanceCriteria": [
        "MQTT uses try_send instead of send().await",
        "ACC uses try_send instead of send().await",
        "Dropped events counted per-source (mqtt_events_dropped, acc_events_dropped)",
        "Warning logged on drop (rate-limited to 1/sec per source)",
        "MQTT eventloop never stalls on tracker backpressure",
        "All existing tests pass"
      ],
      "instructions": "In src/io/mqtt.rs:60 and src/io/acc_listener.rs, change send().await to try_send(). On TrySendError::Full, increment source-specific counter and log rate-limited warning. Add mqtt_events_dropped and acc_events_dropped AtomicU64 to Metrics.",
      "files": ["src/io/mqtt.rs", "src/io/acc_listener.rs", "src/infra/metrics.rs"],
      "priority": 0,
      "passes": false,
      "notes": "CRITICAL: MQTT stalls cause disconnects. Combined MQTT+ACC in one story since same pattern."
    },
    {
      "id": "US-003",
      "title": "RS485 door state: use watch channel for lossless delivery",
      "category": "performance",
      "acceptanceCriteria": [
        "RS485 uses tokio::sync::watch for door state (not mpsc)",
        "Latest door state always available, never dropped",
        "Tracker reads door state from watch receiver",
        "Remove try_send failure path (watch never fails)",
        "Cap read latency: reduce MAX_READ_ATTEMPTS or timeout",
        "All existing tests pass"
      ],
      "instructions": "RS485 door state is stateful (latest value matters, not event stream). Replace mpsc channel with watch channel. RS485Monitor sends via watch::Sender. Tracker/DoorCorrelator receives via watch::Receiver. This ensures door state is never dropped. Also reduce MAX_READ_ATTEMPTS from 50 to 10 to cap stall time at ~500ms.",
      "files": ["src/io/rs485.rs", "src/main.rs", "src/services/tracker/mod.rs"],
      "priority": 0,
      "passes": false,
      "notes": "CRITICAL: Door state is stateful - must be lossless. Watch channel guarantees latest value."
    },
    {
      "id": "US-004",
      "title": "CloudPlus gate queue: try_send with explicit failure handling",
      "category": "performance",
      "acceptanceCriteria": [
        "send_open uses try_send instead of send().await",
        "On queue full: log error, increment gate_cmd_dropped counter, return Err",
        "Caller logs 'gate command dropped due to queue full' at WARN level",
        "Metric: gate_cmds_dropped counter added",
        "Document: dropped command means gate won't open for this customer",
        "All existing tests pass"
      ],
      "instructions": "In src/io/cloudplus.rs:579, change to try_send(). On Full, log and return Err('queue full'). In gate.rs caller, log WARN that gate command was dropped. Add gate_cmds_dropped to Metrics. This is acceptable: if TCP is so backed up, dropping is better than blocking forever.",
      "files": ["src/io/cloudplus.rs", "src/services/gate.rs", "src/infra/metrics.rs"],
      "priority": 1,
      "passes": false,
      "notes": "HIGH: Explicit failure handling - dropped command = customer waits."
    },
    {
      "id": "US-005",
      "title": "Add queue depth and lag metrics for diagnosability",
      "category": "performance",
      "acceptanceCriteria": [
        "Metric: event_queue_depth (current channel size)",
        "Metric: gate_queue_depth (CloudPlus outbound channel size)",
        "Metric: gate_enqueue_to_send_latency_us histogram",
        "Metrics exposed via Prometheus endpoint",
        "Can diagnose 'late gate open' by observing queue lag"
      ],
      "instructions": "Add queue depth tracking: wrap channels with Arc to share capacity checks, or periodically sample len(). For gate latency, record timestamp at enqueue (in GateCmd struct), measure delta at send time. Add to Prometheus output. This makes backlog visible.",
      "files": ["src/infra/metrics.rs", "src/services/gate_worker.rs", "src/io/prometheus.rs"],
      "priority": 1,
      "passes": false,
      "notes": "HIGH: Without queue metrics, 'late gate open' is inferred not diagnosed."
    },
    {
      "id": "US-006",
      "title": "Move journey egress to async worker",
      "category": "performance",
      "acceptanceCriteria": [
        "EgressWriter task owns file handle and receives Journey via channel",
        "Tracker tick_and_egress enqueues to channel, returns immediately",
        "No std::fs on tracker hot path",
        "Batch flush every N journeys or M milliseconds",
        "Write errors logged but don't affect tracker",
        "All existing tests pass"
      ],
      "instructions": "Create EgressWriter task with mpsc::Receiver<Journey>. In tracker, replace direct egress.write_journeys() with channel send. Writer uses spawn_blocking for actual file I/O, or dedicated thread with BufWriter. Flush on batch size or timer.",
      "files": ["src/io/egress.rs", "src/services/tracker/mod.rs", "src/main.rs"],
      "priority": 2,
      "passes": false,
      "notes": "MEDIUM: SSD is fast but sync I/O in async context blocks the runtime."
    },
    {
      "id": "US-007",
      "title": "Cache zone names to avoid per-event allocation",
      "category": "performance",
      "acceptanceCriteria": [
        "Zone names stored as Arc<str> in config",
        "zone_name returns Arc<str> or &str, not String",
        "No allocation on zone_name lookup for known zones",
        "Fallback for unknown zones still works",
        "All callers updated",
        "All tests pass"
      ],
      "instructions": "In Config, change zone_names HashMap value from String to Arc<str>. zone_name() returns Arc<str> clone (cheap) or creates new Arc for unknown zones. Update callers to accept impl AsRef<str>.",
      "files": ["src/infra/config.rs", "src/services/tracker/handlers.rs"],
      "priority": 3,
      "passes": false,
      "notes": "LOW: Per-event String clone adds up under high load."
    },
    {
      "id": "US-008",
      "title": "Reduce per-event logging or add sampling",
      "category": "performance",
      "acceptanceCriteria": [
        "info! logs for zone entry/exit demoted to debug! or sampled",
        "High-frequency events don't spam logs",
        "Critical events (gate_cmd, door state) remain at info!",
        "Optional: add sampling rate config"
      ],
      "instructions": "Review src/services/tracker/handlers.rs for info! on per-event paths. Demote zone_entry/zone_exit to debug! or add sampling (log every Nth event). Keep gate_open_command, gate_open_correlated at info!.",
      "files": ["src/services/tracker/handlers.rs"],
      "priority": 3,
      "passes": false,
      "notes": "LOW: Logging overhead can be significant at high event rates."
    },
    {
      "id": "US-009",
      "title": "Remove MQTT parse_frame HashMap allocation",
      "category": "performance",
      "acceptanceCriteria": [
        "No HashMap allocation per frame",
        "Position lookup uses linear search over tracked_objects",
        "All MQTT parsing tests pass"
      ],
      "instructions": "In src/io/mqtt.rs:129, replace HashMap with linear search: for each event, find matching track_id with tracked_objects.iter().find(). O(n²) is fine for small n (typically <10 objects per frame).",
      "files": ["src/io/mqtt.rs"],
      "priority": 3,
      "passes": false,
      "notes": "LOW: Avoids allocation, O(n²) acceptable for small n."
    }
  ]
}
