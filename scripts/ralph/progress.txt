# Ralph Progress Log - Performance Fixes
Started: 2026-01-10
Branch: ralph/perf-fixes

---

## Codebase Patterns (READ FIRST!)

### Channel Selection Guide
| Data Type | Channel | Reason |
|-----------|---------|--------|
| Events (MQTT/ACC) | mpsc + try_send | High volume, drops acceptable |
| Door state (RS485) | watch | Stateful, latest value matters, lossless |
| Gate commands | mpsc to worker | Decouples from tracker, worker owns network I/O |
| Journey egress | mpsc to writer | Decouples from tracker, writer owns file I/O |

### Non-Blocking Pattern
```rust
// BAD: blocks caller
event_tx.send(event).await?;

// GOOD: returns immediately, tracks drops
match event_tx.try_send(event) {
    Ok(()) => {},
    Err(TrySendError::Full(_)) => {
        metrics.events_dropped.fetch_add(1, Ordering::Relaxed);
        if last_warn.elapsed() > Duration::from_secs(1) {
            warn!("event dropped: channel full");
            last_warn = Instant::now();
        }
    }
    Err(TrySendError::Disconnected(_)) => return,
}
```

### Watch Channel for Stateful Data
```rust
// RS485 door state - latest value always available
let (door_tx, door_rx) = watch::channel(DoorStatus::Unknown);

// Sender (RS485 monitor): never blocks, never fails
door_tx.send_replace(new_status);

// Receiver (Tracker): get latest, never blocks
let status = *door_rx.borrow();
```

### Worker Task Pattern
```rust
// Create channel and spawn worker
let (cmd_tx, cmd_rx) = mpsc::channel(64);
let worker = GateCmdWorker::new(gate_controller, cmd_rx, metrics);
tokio::spawn(async move { worker.run().await });

// In tracker: enqueue and return immediately
cmd_tx.try_send(GateCmd { track_id, received_at }).ok();
```

### Metrics Patterns
- Use `AtomicU64` for lock-free counters
- Add per-source drop counters: `mqtt_events_dropped`, `acc_events_dropped`, `gate_cmds_dropped`
- Queue depth: sample channel len() periodically or wrap in Arc
- Latency: record timestamp at enqueue, measure delta at processing

### Key Files
| File | Purpose | Changes Needed |
|------|---------|----------------|
| `src/services/tracker/handlers.rs:770` | Gate command logic | Enqueue instead of await |
| `src/services/tracker/mod.rs:83` | Main event loop | Add watch receiver for door state |
| `src/services/gate_worker.rs` (NEW) | Gate command worker | Owns GateController, measures latency |
| `src/io/mqtt.rs:60` | MQTT client | try_send + drop counter |
| `src/io/acc_listener.rs` | ACC listener | try_send + drop counter |
| `src/io/rs485.rs` | Door state monitor | watch channel instead of mpsc |
| `src/io/cloudplus.rs:579` | TCP gate queue | try_send with explicit error |
| `src/io/egress.rs` | Journey writer | Async worker, spawn_blocking |
| `src/infra/metrics.rs` | Metrics | Add drop counters, queue depth |

### Problem Context
The tracker loop blocks on network I/O:
1. `send_gate_open_command` awaits TCP (up to 5s timeout)
2. MQTT/ACC use `send().await` (blocks if tracker slow)
3. RS485 uses mpsc + try_send (drops door state on full channel)

Consequences:
- Gate commands arrive late ("gate open too late")
- MQTT eventloop stalls → missed keepalives → disconnects
- Door state can be lost, breaking correlation

### Solution Architecture
```
┌─────────────────────────────────────────────────────────────┐
│                        INGRESS                               │
├─────────────────────────────────────────────────────────────┤
│  MQTT ──try_send──> │                                        │
│  ACC  ──try_send──> │  event_rx (mpsc, 1000 capacity)        │
│                     │                                        │
│  RS485 ──watch───> door_rx (watch, always latest)            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       TRACKER                                │
│  - Receives events from event_rx                            │
│  - Reads door state from door_rx.borrow()                   │
│  - Enqueues gate commands to gate_cmd_tx (never awaits)     │
│  - Enqueues journeys to egress_tx (never awaits)            │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                       WORKERS                                │
├─────────────────────────────────────────────────────────────┤
│  GateCmdWorker: gate_cmd_rx → gate.send_open_command()      │
│    - Measures queue delay + send latency                    │
│    - Updates metrics                                        │
│                                                             │
│  EgressWriter: egress_rx → spawn_blocking file write        │
│    - Batches journeys                                       │
│    - Flushes on count or timer                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Completed Stories

### US-001: Decouple gate commands from tracker loop ✓
**Commit:** 0965cc3 feat: [US-001] - Decouple gate commands from tracker loop

**Changes:**
- Created `src/services/gate_worker.rs` with `GateCmdWorker` task
- Worker owns `GateController` and receives commands via mpsc channel
- Tracker enqueues gate commands with `try_send()` - never awaits network I/O
- Worker measures queue delay and send latency, logs timing breakdown
- All event handlers made synchronous (no more `.await` on hot path)
- Gate state payload changed from "cmd_sent" to "cmd_enqueued"

**Files modified:**
- `src/services/gate_worker.rs` (NEW)
- `src/services/tracker/handlers.rs` - sync handlers, try_send to channel
- `src/services/tracker/mod.rs` - uses gate_cmd_tx instead of gate Arc
- `src/services/mod.rs` - exports gate_worker module
- `src/main.rs` - spawns GateCmdWorker task
- `src/services/tracker/tests.rs` - updated for sync process_event

**Key insight:** This is the PRIMARY fix for "gate open too late" - network I/O
no longer blocks the tracker event loop.

---

## Story Progress

